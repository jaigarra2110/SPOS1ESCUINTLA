<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algoritmo del Banquero: Simulador Interactivo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .log-success { color: #22c55e; }
        .log-error { color: #ef4444; }
        .log-info { color: #3b82f6; }
        .log-step { color: #a1a1aa; }
        .highlight-card { box-shadow: 0 0 0 3px #3b82f6; transition: all 0.3s; }
        [contenteditable]:focus {
            outline: 2px solid #3b82f6;
            background-color: #1e293b;
            border-radius: 4px;
        }
        .progress-bar { background-color: #334155; }
        .progress-bar-fill { background-color: #3b82f6; }
    </style>
</head>
<body class="bg-slate-900 text-gray-200">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white mb-2">Simulador del Algoritmo del Banquero</h1>
            <p class="text-lg text-gray-400">Un tutorial interactivo para entender la evasión de interbloqueos.</p>
        </header>

        <section class="bg-slate-800 p-6 rounded-lg shadow-lg mb-8">
            <h2 class="text-2xl font-semibold mb-4 border-b border-slate-700 pb-2">La Analogía del Banquero y los Grafos</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                <div>
                    <p class="mb-4">El Algoritmo del Banquero previene interbloqueos (<i>deadlocks</i>) al no conceder una solicitud de recursos a menos que pueda garantizar que el sistema permanecerá en un <strong>estado seguro</strong>. Un estado es seguro si existe al menos una secuencia en la que todos los procesos pueden completarse.</p>
                    <p>Funciona evitando la formación de <strong>ciclos de espera</strong> en un Grafo de Asignación de Recursos, donde un Proceso (círculo) espera por un Recurso (cuadrado) que está asignado a otro proceso, que a su vez espera por otro recurso, creando una cadena irrompible.</p>
                </div>
                <div class="text-center p-4 bg-slate-900 rounded-lg">
                    <svg viewBox="0 0 200 200" class="w-full max-w-xs mx-auto text-gray-300" aria-labelledby="graphTitle">
                        <title id="graphTitle">Grafo de Asignación de Recursos con Ciclo de Interbloqueo</title>
                        <defs>
                            <marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="currentColor" />
                            </marker>
                        </defs>
                        <rect x="140" y="40" width="20" height="20" rx="2" fill="none" stroke="currentColor" stroke-width="1.5"/><text x="150" y="54" font-size="10" text-anchor="middle" fill="currentColor">R1</text>
                        <rect x="40" y="140" width="20" height="20" rx="2" fill="none" stroke="currentColor" stroke-width="1.5"/><text x="50" y="154" font-size="10" text-anchor="middle" fill="currentColor">R2</text>
                        <circle cx="50" cy="50" r="10" fill="none" stroke="currentColor" stroke-width="1.5"/><text x="50" y="54" font-size="10" text-anchor="middle" fill="currentColor">P1</text>
                        <circle cx="150" cy="150" r="10" fill="none" stroke="currentColor" stroke-width="1.5"/><text x="150" y="154" font-size="10" text-anchor="middle" fill="currentColor">P2</text>
                        <line x1="140" y1="50" x2="60" y2="50" stroke="currentColor" stroke-width="1" marker-end="url(#arrow)" /><line x1="50" y1="60" x2="50" y2="140" stroke="currentColor" stroke-width="1" marker-end="url(#arrow)" /><line x1="60" y1="150" x2="140" y2="150" stroke="currentColor" stroke-width="1" marker-end="url(#arrow)" /><line x1="150" y1="140" x2="150" y2="60" stroke="currentColor" stroke-width="1" marker-end="url(#arrow)" />
                    </svg>
                    <p class="text-sm text-gray-400 mt-2">Ejemplo de interbloqueo: P1 espera a R2 (en posesión de P2) y P2 espera a R1 (en posesión de P1).</p>
                </div>
            </div>
        </section>

        <main class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <div class="space-y-8">
                <div class="bg-slate-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-2xl font-semibold mb-4 border-b border-slate-700 pb-2">Configuración del Sistema</h2>
                    <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-4 gap-4">
                        <div>
                            <label for="total-resources" class="font-medium text-gray-400">Recursos Totales: </label>
                            <input id="total-resources" class="bg-slate-700 text-lg font-mono text-blue-400 p-1 rounded-md w-36" value="9,3,6">
                        </div>
                        <p class="text-center"><span class="font-medium text-gray-400">Disponibles: </span><code id="available-vector" class="text-lg font-mono text-blue-400"></code></p>
                    </div>
                    <!-- Contenedor de Tarjetas de Procesos -->
                    <div id="process-cards-container" class="space-y-4"></div>
                    <button id="add-process-btn" class="mt-4 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition duration-200">+ Añadir Proceso</button>
                </div>

                <div class="bg-slate-800 p-6 rounded-lg shadow-lg">
                    <h2 class="text-2xl font-semibold mb-4 border-b border-slate-700 pb-2">Acciones de Simulación</h2>
                    <div class="space-y-4">
                        <button id="check-safety-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-200">Verificar Estado de Seguridad</button>
                    </div>
                    <div class="mt-6 space-y-4">
                        <h3 class="text-xl font-semibold border-t border-slate-700 pt-4">Evaluar Solicitud de Recursos</h3>
                        <div class="flex items-center gap-4">
                            <select id="request-process-select" class="bg-slate-700 rounded-md p-2"></select>
                            <label for="request-vector">solicita</label>
                            <input id="request-vector" class="bg-slate-700 p-2 rounded-md font-mono flex-grow" placeholder="Ej: 1,0,2">
                        </div>
                        <button id="evaluate-request-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition duration-200">Evaluar Solicitud</button>
                    </div>
                     <div class="mt-6">
                        <button id="reset-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition duration-200">Reiniciar Simulación</button>
                    </div>
                </div>
            </div>

            <div class="bg-slate-800 p-6 rounded-lg shadow-lg">
                 <h2 class="text-2xl font-semibold mb-4 border-b border-slate-700 pb-2">Ejecución y Evaluación</h2>
                 <div id="log-output" class="w-full h-[calc(100%-4rem)] bg-slate-900 rounded-md p-4 font-mono text-sm overflow-y-auto whitespace-pre-wrap">
                    <span class="text-gray-500">Los resultados de la simulación aparecerán aquí...</span>
                 </div>
            </div>
        </main>
        
        <section class="bg-slate-800 p-6 rounded-lg shadow-lg mt-8">
            <h2 class="text-2xl font-semibold mb-4 border-b border-slate-700 pb-2">Preguntas para Estudiantes</h2>
            <div class="space-y-4 text-gray-300">
                <p>Usa el simulador para responder las siguientes preguntas:</p>
                <ol class="list-decimal list-inside space-y-3">
                    <li><strong>Solicitud Máxima:</strong> Con el estado inicial, ¿qué sucede si P0 solicita inmediatamente todos los recursos que necesita (`2,2,2`)? ¿Por qué el sistema responde de esa manera?</li>
                    <li><strong>Estado Inseguro:</strong> Encuentra una solicitud para P2 que sea menor a los recursos disponibles, pero que el sistema rechace porque llevaría a un estado inseguro. Documenta la solicitud y la secuencia de eventos.</li>
                    <li><strong>Abundancia de Recursos:</strong> Reinicia la simulación y cambia los "Recursos Totales" a `12,5,7`. ¿Cambia la primera secuencia segura que encuentra el algoritmo? ¿Por qué?</li>
                    <li><strong>Liberación de Recursos:</strong> Reinicia y elimina el proceso P1 (el que más recursos tiene asignados). ¿Cómo afecta esto a la disponibilidad de recursos y a la seguridad del sistema?</li>
                    <li><strong>Nuevo Proceso:</strong> Añade un nuevo proceso P4 con `Asignado = [0,1,1]` y `Máximo = [2,2,2]`. ¿Es el sistema seguro después de añadirlo? ¿Puede P4 terminar inmediatamente?</li>
                </ol>
            </div>
        </section>

    </div>

    <script>
        const initial_state = {
            totalResources: [9, 3, 6],
            processes: [
                { id: 0, allocation: [1, 0, 0], max: [3, 2, 2] },
                { id: 1, allocation: [6, 1, 2], max: [6, 1, 3] },
                { id: 2, allocation: [2, 1, 1], max: [3, 1, 4] },
                { id: 3, allocation: [0, 0, 2], max: [4, 2, 2] },
            ]
        };

        let currentState;
        let nextProcessId = 4;

        // --- DOM ELEMENTS ---
        const availableVectorEl = document.getElementById('available-vector');
        const processCardsContainer = document.getElementById('process-cards-container');
        const logOutputEl = document.getElementById('log-output');
        const checkSafetyBtn = document.getElementById('check-safety-btn');
        const evaluateRequestBtn = document.getElementById('evaluate-request-btn');
        const resetBtn = document.getElementById('reset-btn');
        const addProcessBtn = document.getElementById('add-process-btn');
        const totalResourcesInput = document.getElementById('total-resources');
        const requestProcessSelect = document.getElementById('request-process-select');
        const requestVectorInput = document.getElementById('request-vector');

        // --- CORE LOGIC ---
        const vectorToString = (vec) => `[${vec.join(', ')}]`;
        const stringToVector = (str) => str.split(',').map(n => parseInt(n.trim(), 10)).filter(n => !isNaN(n));
        const isLessOrEqual = (a, b) => a.length === b.length && a.every((v, i) => v <= b[i]);
        const addVectors = (a, b) => a.map((v, i) => v + (b[i] || 0));
        const subtractVectors = (a, b) => a.map((v, i) => v - (b[i] || 0));
        const calculateNeed = (p) => subtractVectors(p.max, p.allocation);
        
        function calculateAvailable(processes, totalResources) {
            const totalAllocation = processes
                .reduce((sum, p) => addVectors(sum, p.allocation), new Array(totalResources.length).fill(0));
            return subtractVectors(totalResources, totalAllocation);
        }

        async function runSafetyAlgorithm(state, log) {
            log.push(`<span class="log-info">Iniciando Algoritmo de Seguridad...</span>`);
            const available = calculateAvailable(state.processes, state.totalResources);
            let work = [...available];
            log.push(`<span class="log-step">Capital de trabajo (Work) = Available = ${vectorToString(work)}</span>`);
            
            let finish = new Array(state.processes.length).fill(false);
            const needs = state.processes.map(calculateNeed);
            let sequence = [];
            
            let possible = true;
            while(sequence.length < state.processes.length && possible) {
                let foundProcess = false;
                for (let i = 0; i < state.processes.length; i++) {
                    if (!finish[i] && isLessOrEqual(needs[i], work)) {
                        highlightCard(i, true);
                        log.push(`<span class="log-step">Ronda ${sequence.length + 1}: Se encontró P${state.processes[i].id}.</span>`);
                        log.push(`  <span class="log-step">Su Necesidad ${vectorToString(needs[i])} es &le; a nuestro Work ${vectorToString(work)}.</span>`);
                        await sleep(800);

                        work = addVectors(work, state.processes[i].allocation);
                        finish[i] = true;
                        sequence.push(`P${state.processes[i].id}`);
                        foundProcess = true;
                        
                        log.push(`  <span class="log-step">P${state.processes[i].id} termina y libera ${vectorToString(state.processes[i].allocation)}.</span>`);
                        log.push(`  <span class="log-step">Nuevo Work = ${vectorToString(work)}</span>`);
                        updateLog(log);
                        highlightCard(i, false, true);
                        await sleep(1000);
                        break;
                    }
                }
                if (!foundProcess) possible = false;
            }

            if (sequence.length === state.processes.length) {
                log.push(`<span class="log-success">CONCLUSIÓN: El estado es SEGURO.</span>`);
                log.push(`<span class="log-success">Una secuencia segura es: &lt;${sequence.join(', ')}&gt;</span>`);
                return { safe: true, log };
            } else {
                log.push(`<span class="log-error">CONCLUSIÓN: El estado es INSEGURO. No se puede garantizar que todos los procesos terminen.</span>`);
                return { safe: false, log };
            }
        }
        
        // --- UI FUNCTIONS ---
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        const updateLog = (log) => {
            logOutputEl.innerHTML = log.join('<br>');
            logOutputEl.scrollTop = logOutputEl.scrollHeight;
        };

        function highlightCard(index, active, finished = false) {
            const cards = processCardsContainer.children;
            if(cards[index]) {
                cards[index].classList.remove('highlight-card');
                if(active) cards[index].classList.add('highlight-card');
                if(finished) {
                    cards[index].style.backgroundColor = '#15803d40';
                    cards[index].style.textDecoration = 'line-through';
                    cards[index].style.opacity = '0.6';
                } else {
                    cards[index].style.backgroundColor = '';
                    cards[index].style.textDecoration = '';
                    cards[index].style.opacity = '1';
                }
            }
        }
        
        function render(state) {
            const available = calculateAvailable(state.processes, state.totalResources);
            availableVectorEl.textContent = vectorToString(available);
            totalResourcesInput.value = state.totalResources.join(',');

            processCardsContainer.innerHTML = '';
            requestProcessSelect.innerHTML = '';
            
            state.processes.forEach((p) => {
                const need = calculateNeed(p);
                const card = document.createElement('div');
                card.className = 'bg-slate-700 p-4 rounded-lg shadow-md transition-all duration-300';
                card.dataset.pid = p.id;

                let resourceHTML = '';
                for (let i = 0; i < state.totalResources.length; i++) {
                    const allocation = p.allocation[i] || 0;
                    const max = p.max[i] || 0;
                    const percentage = max > 0 ? (allocation / max) * 100 : 0;
                    resourceHTML += `
                        <div class="mb-2">
                            <div class="flex justify-between items-center text-sm mb-1">
                                <span class="font-bold">R${i}</span>
                                <div class="font-mono text-xs">
                                    <span>Asignado: <span contenteditable="true" data-pid="${p.id}" data-type="allocation" data-index="${i}">${allocation}</span></span> /
                                    <span>Máx: <span contenteditable="true" data-pid="${p.id}" data-type="max" data-index="${i}">${max}</span></span>
                                </div>
                            </div>
                            <div class="w-full h-4 rounded-full progress-bar overflow-hidden">
                                <div class="h-full rounded-full progress-bar-fill" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    `;
                }

                card.innerHTML = `
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="text-xl font-bold">Proceso P${p.id}</h3>
                        <button data-pid="${p.id}" class="remove-process-btn text-red-500 hover:text-red-400 font-bold text-2xl leading-none">&times;</button>
                    </div>
                    ${resourceHTML}
                    <div class="text-right text-sm text-gray-400 mt-2">
                        Necesidad: <code class="font-mono">${vectorToString(need)}</code>
                    </div>
                `;
                processCardsContainer.appendChild(card);

                const option = document.createElement('option');
                option.value = p.id;
                option.textContent = `P${p.id}`;
                requestProcessSelect.appendChild(option);
            });
        }
        
        // --- EVENT HANDLERS ---
        function handleStateUpdate() {
            render(currentState);
        }

        totalResourcesInput.addEventListener('blur', () => {
            const vec = stringToVector(totalResourcesInput.value);
            if (vec.length > 0) {
                currentState.totalResources = vec;
                handleStateUpdate();
            }
        });

        processCardsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('remove-process-btn')) {
                const pid = parseInt(e.target.dataset.pid, 10);
                currentState.processes = currentState.processes.filter(p => p.id !== pid);
                handleStateUpdate();
            }
        });
        
        processCardsContainer.addEventListener('blur', (e) => {
            if (e.target.hasAttribute('contenteditable')) {
                const pid = parseInt(e.target.dataset.pid, 10);
                const type = e.target.dataset.type;
                const index = parseInt(e.target.dataset.index, 10);
                const process = currentState.processes.find(p => p.id === pid);
                const newValue = parseInt(e.target.textContent, 10);

                if (process && !isNaN(newValue)) {
                    process[type][index] = newValue;
                    handleStateUpdate();
                } else if(process) {
                    e.target.textContent = process[type][index]; // revert
                }
            }
        }, true);


        addProcessBtn.addEventListener('click', () => {
            const resourceCount = currentState.totalResources.length;
            currentState.processes.push({
                id: nextProcessId++,
                allocation: new Array(resourceCount).fill(0),
                max: new Array(resourceCount).fill(0),
            });
            handleStateUpdate();
        });

        checkSafetyBtn.addEventListener('click', async () => {
            render(currentState); // Rerender to remove highlights
            let log = [];
            updateLog(log);
            const result = await runSafetyAlgorithm(currentState, log);
            updateLog(result.log);
        });

        evaluateRequestBtn.addEventListener('click', async () => {
            render(currentState); // Rerender to remove highlights
            let log = [];
            updateLog(log);

            const processId = parseInt(requestProcessSelect.value, 10);
            const request = stringToVector(requestVectorInput.value);
            const process = currentState.processes.find(p => p.id === processId);

            if (!process || request.length !== currentState.totalResources.length) {
                log.push(`<span class="log-error">Error: Solicitud inválida o proceso no encontrado.</span>`);
                updateLog(log); return;
            }

            log.push(`<span class="log-info">Evaluando si P${processId} puede solicitar ${vectorToString(request)}...</span>`);
            const need = calculateNeed(process);
            const available = calculateAvailable(currentState.processes, currentState.totalResources);
            await sleep(800);

            log.push(`<span class="log-step">1. ¿Solicitud &le; Necesidad? (${vectorToString(request)} &le; ${vectorToString(need)})</span>`);
            await sleep(1000);
            if (!isLessOrEqual(request, need)) {
                log.push(`<span class="log-error">NO. El proceso pide más de lo que necesita. Solicitud denegada.</span>`);
                updateLog(log); return;
            }
            log.push(`<span class="log-success">SÍ. Solicitud válida.</span>`);
            await sleep(1000);

            log.push(`<span class="log-step">2. ¿Solicitud &le; Disponible? (${vectorToString(request)} &le; ${vectorToString(available)})</span>`);
            await sleep(1000);
            if (!isLessOrEqual(request, available)) {
                log.push(`<span class="log-error">NO. No hay suficientes recursos. El proceso debe esperar.</span>`);
                updateLog(log); return;
            }
            log.push(`<span class="log-success">SÍ. Recursos disponibles.</span>`);
            log.push(`<span class="log-info">Simulando asignación para verificar seguridad...</span>`);
            updateLog(log);
            await sleep(1500);

            let tempState = JSON.parse(JSON.stringify(currentState));
            let tempProcess = tempState.processes.find(p => p.id === processId);
            tempProcess.allocation = addVectors(tempProcess.allocation, request);
            
            const safetyResult = await runSafetyAlgorithm(tempState, log);
            
            if (safetyResult.safe) {
                log.push(`<span class="log-success">DECISIÓN FINAL: La solicitud SE CONCEDE.</span>`);
                currentState = tempState;
                handleStateUpdate();
            } else {
                 log.push(`<span class="log-error">DECISIÓN FINAL: La solicitud SE DENIEGA. Llevaría a un estado inseguro.</span>`);
            }
            updateLog(log);
        });
        
        resetBtn.addEventListener('click', () => {
            currentState = JSON.parse(JSON.stringify(initial_state));
            nextProcessId = currentState.processes.reduce((maxId, p) => Math.max(maxId, p.id), 0) + 1;
            render(currentState);
            logOutputEl.innerHTML = `<span class="text-gray-500">Simulación reiniciada.</span>`;
        });

        // --- INITIALIZATION ---
        resetBtn.click();

    </script>
</body>
</html>

